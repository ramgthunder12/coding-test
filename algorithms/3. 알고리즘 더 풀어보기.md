# 알고리즘 더 풀어보기

## 반복되지 않는 첫번째 문자

### 문제 설명

다음과 같이 영어로 되어 있는 문자열이 있을 때, 이 문자열에서 반복되지 않는 첫번째 문자를 반환하시오. 만약 그런 문자가 없다면 _ 를 반환하시오.

### 1. 개념

- 문자 빈도수(counting)
- 배열을 이용한 빈도 기록
- 문자를 숫자로 바꿔 인덱스로 사용하는것이 핵심

### 2. 판단 기준

- 문자의 등장 횟수를 구할때  
- 아스키코드로 연속되는 문자들 일때  
- "첫번째" 등 순서를 확인하려고 문자열을 다시 순회 할때

👉 빈도 기록 + 원본 순회

### 3. 풀이 방법

1. 알파뱃의 빈도수를 저장한다.
2. 빈도수 가 1인 인덱스를 알파뱃으로 변환한다.
3. 문자열에서 해당 알파뱃이 있는지 확인한다.

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class FindNotRepeatingFirstCharacter {
    public static char findNotRepeatingFirstCharacter(String string) {
        //알파뱃의 빈도수 저장한다.
        int[] alphabetOccurrenceArray = findAlphabetOccurrenceArray(string);
        //빈도수가 1인 인덱스번호를 문자로 변경한다.
        //그 값을 배열에 담는다.
        ArrayList<Character> oneCountAlphabetArray = new ArrayList<>();
        for(int i = 0; i < 26; i++) {
            if(alphabetOccurrenceArray[i] == 1) {
                oneCountAlphabetArray.add((char) (i + 'a'));
            }
        }
        //string을 돌면서 배열에 담긴값과 비교한다.
        //string에 있는 값중 배열에 담긴값이 일치하면 바로 반환한다.
        for(int i = 0; i < string.length(); i++) {
            for(int j = 0; j < oneCountAlphabetArray.size(); j++) {
                if(string.charAt(i) == oneCountAlphabetArray.get(j)) {
                    return oneCountAlphabetArray.get(j);
                    
                }   
            }
        }
        
        return '_';
    }

    public static int[] findAlphabetOccurrenceArray(String string) {
        int[] alphabetOccurrenceArray = new int[26];
        
        for(int i = 0; i < string.length(); i++) {
            alphabetOccurrenceArray[i] = 0;
        }
        
        for(int i = 0; i < string.length(); i++) {
            alphabetOccurrenceArray[string.charAt(i) - 97] = alphabetOccurrenceArray[string.charAt(i) - 97] + 1;
        }
        return alphabetOccurrenceArray;
    }

    public static void main(String[] args) {
        System.out.println("정답 = d 현재 풀이 값 = " + findNotRepeatingFirstCharacter("abadabac"));
        System.out.println("정답 = c 현재 풀이 값 = " + findNotRepeatingFirstCharacter("aabbcddd"));
        System.out.println("정답 = _ 현재 풀이 값 = " + findNotRepeatingFirstCharacter("aaaaaaaa"));
    }
}
```

시간복잡도 O(N²)  


```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class FindNotRepeatingFirstCharacter {
    public static char findNotRepeatingFirstCharacter(String string) {
        //알파뱃의 빈도수 저장한다.
        int[] alphabetOccurrenceArray = findAlphabetOccurrenceArray(string);
        //빈도수가 1인 인덱스번호를 문자로 변경한다.
        //그 값을 배열에 담는다.
        ArrayList<Character> oneCountAlphabetArray = new ArrayList<>();
        for(int i = 0; i < 26; i++) {
            if(alphabetOccurrenceArray[i] == 1) {
                oneCountAlphabetArray.add((char) (i + 'a'));
            }
        }
        //string을 돌면서 배열에 담긴값과 비교한다.
        //string에 있는 값중 배열에 담긴값이 일치하면 바로 반환한다.
        for(int i = 0; i < string.length(); i++) {
            if(oneCountAlphabetArray.contains(string.charAt(i))) {
                return string.charAt(i);
            }
        }
        
        return '_';
    }

    public static int[] findAlphabetOccurrenceArray(String string) {
        int[] alphabetOccurrenceArray = new int[26];
        
        for(int i = 0; i < string.length(); i++) {
            alphabetOccurrenceArray[i] = 0;
        }
        
        for(int i = 0; i < string.length(); i++) {
            alphabetOccurrenceArray[string.charAt(i) - 97] = alphabetOccurrenceArray[string.charAt(i) - 97] + 1;
        }
        return alphabetOccurrenceArray;
    }

    public static void main(String[] args) {
        System.out.println("정답 = d 현재 풀이 값 = " + findNotRepeatingFirstCharacter("abadabac"));
        System.out.println("정답 = c 현재 풀이 값 = " + findNotRepeatingFirstCharacter("aabbcddd"));
        System.out.println("정답 = _ 현재 풀이 값 = " + findNotRepeatingFirstCharacter("aaaaaaaa"));
    }
}
```
### 4. 시간복잡도 

O(N)

### 5. 실수 포인트

- 문자열을 돌면서, ArrayList를 돌 필요가 없음

### 6. 복기  

- 정렬, 탐색문제 아님  
- 빈도 + 순서 문제



## 소수나열하기

### 문제 설명

정수를 입력 했을 때, 그 정수 이하의 소수를 모두 반환하시오. 

소수는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수이다.

### 1. 개념  

- 소수 : 1과 자기 자신을 제외하고 나눌수 없다.
- 어떤 수의 제곱이 소수를 넘지 않아한다.
- 반복 되는 부분이 없도록 한다.

### 2. 판단 기준

- N 이하의 모든 소수 목록 생성
- N이 최대 100000임으로 완전탐색(다 탐색) 오래 걸림
- 이전 결과 재사용
👉 소수 리스트를 누적하면서 판별해야함

### 3. 풀이 방법
1. 2부터 number 전까지 확인한다.
2. 현재 숫자를 이미 구한 소수들로만 나눔
3. 나누는 값의 제곱이 현재의 값과 같거나 작아야 한다.  
    합성수N : 루트 N 이하의 약수를 하나 이상 가진다.
4. 나눠지지 않으면 소수로 판단한다.

```
import java.util.ArrayList;
import java.util.List;

class FindPrimeListUnderNumber {
    // 소수는 자기 자신과 1외 에는 아무것도 나눌 수 없다.
    public static List<Integer> findPrimeListUnderNumber(int number) {
        List<Integer> primeList = new ArrayList<>();
        
        for(int i = 2; i < number; i++) {
            boolean isPrime = true;
            for(int j = 2; j < primeList.size(); j++) {
                if(j * j <= i && i % j == 0) {
                    isPrime = false;
                    break;
                }   
            }
            if(isPrime) {
                primeList.add(i);
            }
        }

        return primeList;
    }

    public static void main(String[] args) {
        int input = 20;
        List<Integer> result = findPrimeListUnderNumber(input);
        System.out.println(result);
    }
}
```

### 시간복잡도  
O(N²)

### 5. 실수 포인트

- 모든 수로 나누면 시간이 오래걸림  
- 1을 소수로 포함 시키면 안됨

### 6. 복기  
- 나눌때 어디까지 나눌것인가 확인
- 최소한의 반복 생각하기



## 문자열 뒤집기

### 문제 설명

0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자열에 있는 모든 숫자를 전부 같게 만들려고 한다. 할 수 있는 행동은 문자열에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.

예를 들어 S=0001100 일 때,

전체를 뒤집으면 1110011이 된다.
4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.
하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.

주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오.

### 1. 개념  

- 연속된 문자는 하나의 덩어리로 본다.  
- 한번의 뒤집기는 하나의 덩어리를 통째로 바꾸는것을 의미  
- Greedy그리디 문제  

### 2. 판단 기준

- 연속된 하나 이상의 숫자를 뒤집는다.  
- 최소 횟수  
- 모든 경우의 수를 사용하지 않아도 될때  

👉 문자 하나하나가 아니라 ‘덩어리 개수’를 세는 문제

### 3. 풀이 방법

덩어리를 뒤집는 횟수  

1. 0에서 1로 바뀔때 또는 1에서 0으로 바뀔때의 횟수를 센다.
2. 첫번째 값이 0이면 0의 횟수를 1회 추가한다. 1이면 1의 횟수를 1회 추가한다.


```java
class FindCountToTurnOutToAllZeroOrAllOne {
    // 0 에서 1을 마주쳤을 때 뒤집는다 -> 전체를 0으로 만들기 위한 작업
    // 1 에서 0을 마주쳤을 때 뒤집는다 -> 전체를 1로 만들기 위한 작업

    public static int findCountToTurnOutToAllZeroOrAllOne(String string) {
        int countOne = 0;
        int countZero = 0;
        
        if(string.charAt(0) == '0') {
            countZero = countZero + 1;
        } else {
            countOne = countOne + 1;
        }
        
        for(int i = 0; i < string.length() - 1; i++) {
            int firstChar = string.charAt(i);
            int secondChar = string.charAt(i + 1);
            if(firstChar != secondChar) {
                if(firstChar == '0') {
                    countZero = countZero + 1;
                } else {
                    countOne = countOne + 1;
                }
            
            }
        }
        
        if(countOne >= countZero) {
            return countZero;
        } else {
            return countOne;
        }
    }

    public static void main(String[] args) {
        String input = "011110";
        int result = findCountToTurnOutToAllZeroOrAllOne(input);
        System.out.println(result);
    }
}
```

### 4. 시간복잡도  
O(N)

### 5. 실수 포인트

- 첫번째 문자 덩어리 처리 해야함  
- 모든 경우를 탐색하면 안됌

### 6. 복기

- 문자 하나가 아닌 덩어리  
- 덩어리 한번에 뒤집는 방식 -> 그리디. 

👉 “변화 지점이 몇 개인가?”부터 떠올릴 것

## 문자열 요약해보기

### 문제 설명 

1. 입력으로 소문자의 알파벳 순으로 정렬된 문자열이 입력됩니다.
2. 각 알파벳은 중복이 가능합니다.
3. 중간에 없는 알파벳이 있을 수도 있습니다.

입,출력 예시와 같이 입력 문자열에 나타나는 각 알파벳의 종류,갯수를 요약하여 나타내시오.

### 1. 개념

- 문자 빈도수(counting)  
- Counting sort와 비슷

### 2. 판단 기준

- 각 알파벳의 종류와 개수를 요약  

👉 정렬할 필요 없음 → 빈도만 세면 됨

### 3. 풀이 방법

1. 26개의 배열에 0을 담는다.  
2. 문자열을 돌면서 해당 문자 - 97의 인덱스의 값에 1을 더한다.  
3. 26개 배열에서 값이 0이상인 값을 문자열에 담는다.

```java
import java.util.Arrays;
class Main {
    public static String stringCountSort(String str) {
        int[] alphabet = new int[26];
        String answer = "";
        
        for(int i = 0; i < alphabet.length; i++) {
            alphabet[i] = 0;
        }
        
        for(int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            alphabet[(int)c - 97] = alphabet[(int)c - 97] + 1;
        }
        System.out.println(Arrays.toString(alphabet));

        for(int i = 0; i < alphabet.length; i++) {
            int count = alphabet[i];
            if(count > 0) {
                answer = answer + (char)(i + 97) + count;
            }
        }
        return answer;
    }
    
    public static void main(String[] args) {
        System.out.println("Ex 1)");
        System.out.println("abc    # " + stringCountSort("aaabbbc"));
        System.out.println("Ex 2-1)");
        System.out.println("aaabbbc    # " + stringCountSort("abbbc"));
        System.out.println("Ex 2-2)");
        System.out.println("abbbc    # " + stringCountSort("ahhhhz"));
        System.out.println("Ex 3-1)");
        System.out.println("aahhhhz   # " + stringCountSort("ahhhhz"));
        System.out.println("Ex 3-21)");
        System.out.println("acccdeee    # " + stringCountSort("acccdeee"));
    }
}
```

### 4. 시간복잡도  
O(N)

### 5. 실수 포인트

- String + String 새로운 객체 생성으로 성능 저하
- 문자 -> 숫자 변환 주의
- 정렬 안해도됨

### 6. 복기

- 빈도 문제
- 문자 종류 제한 -> 배열이 최적화됨. 
 
👉 Counting 배열 먼저 떠올릴 것

## 핵심

1. 첫번째 중복 안된 문자 : 아스키코드, counting
2. 소수 : 나눠서 0이 되는수, 합성수(i^2 <= N) 이 아닌 수
3. 덩어리 횟수 : 값이 변화 할때, 첫번째 값 넣기
4. 문자열 뒤집기 : counting
