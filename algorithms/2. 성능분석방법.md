# 성능 측정

## 측정 방법

### Time complexity 시간복잡도

연산의 횟수를 계산하는 방법  
- N : 입력 받은 값의 길이 만큼 연산 하는 횟수
- 반복문 안에서의 연산 횟수는, 한 반복안에서 실행 되는 횟수로 계산 해야 한다.

**예시**
```python
    for number in array:                 # array 의 길이만큼 아래 연산이 실행
        is_max_num = True                # 대입 연산 1번 실행
        for compare_number in array:     # array 의 길이만큼 아래 연산이 실행
            if number < compare_number:  # 비교 연산 1번 실행
                is_max_num = False       # 대입 연산 1번 실행
        if is_max_num:                   # 비교 연산 1번 실행
            return number
    
# N * (1 + N(1 + 1) + 1)
# = 2N² + 2N
# 시간 복잡도 O(N²)


    max_num = array[0]                    # 대입 연산 1번 실행
    for num in array:                     # array 의 길이 만큼 아래 연산이 실행
        if num > max_num:                 # 비교 연산 1번 실행
            max_num = num                 # 대입 연산 1번 실행
    return max_num

# 1 + N(1 + 1)
# = 2N + 1
# 시간 복잡도 O(N)
```

### Space complexity 공간복잡도

데이터가 저장되는 공간의 갯수를 계산하는 방법  
1. 배열 : 배열의 길이 만큼 공간의 갯수를 가진다.
2. 변수 : 변수의 갯수 만큼 공간의 갯수를 가진다.

```python
    alphabet_array = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z"]
# -> 26 개의 공간을 사용합니다
    max_occurrence = 0 # 1개의 공간을 사용합니다
    max_alphabet = alphabet_array[0]   # 1개의 공간을 사용합니다.

    for alphabet in alphabet_array:
        occurrence = 0  # 1개의 공간을 사용합니다

# 공간의 갯수 = 29
# 공간 복잡도 O(1)


    alphabet_occurrence_list = [0] * 26 # -> 26 개의 공간을 사용합니다

    for char in string:
        if not char.isalpha():
            continue
        arr_index = ord(char) - ord('a')  # 1개의 공간을 사용합니다
        alphabet_occurrence_list[arr_index] += 1

    max_occurrence = 0                   # 1개의 공간을 사용합니다
    max_alphabet_index = 0               # 1개의 공간을 사용합니다
    for index in range(26):
        alphabet_occurrence = alphabet_occurrence_list[index] # 1개의 공간을 사용합니다
        if alphabet_occurrence > max_occurrence:
            max_occurrence = alphabet_occurrence
            max_alphabet_index = index

# 공간의 갯수 = 30
# 공간 복잡도 O(1)
```


## 표기 방법

### Big-O

최악의 성능을 표기하는 방법  
최고로 걸리는 시간을 기준으로 분석한 방법이다.

### Big-Ω

최선의 성능을 표기하는 방법  
최소로 걸리는 시간을 기준으로 분석한 방법이다.

## 예시 알고리즘

### 곱하기, 더하기 중 큰값 구하기

- 문제  
    다음과 같이 0 혹은 양의 정수로만 이루어진 배열이 있을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 '✕' 혹은 '+' 연산자를 넣어 결과적으로 가장 큰 수를 구하는 프로그램을 작성하시오. 

    단, '+' 보다 '✕' 를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서 순서대로 이루어진다.
    ```
    [0, 3, 5, 6, 1, 2, 4]
    ```
- 해결방법  
    
1. 반복문을 돌면서 answer이라는 변수에 계산된 값을 담는다. 
2. 연산하는 값이 0 또는 1이면 덧셈을 한다.
3. 이외의 연산하는 값은 곱셈을 한다.  

```java
    public static int result(int[] array) {
        int answer = 0;                     //대입 연산 1번 실행
        for(int i : array) {                //입력 연산 N번 실행
            if(answer < 2 || i < 2) {       //비교 연산 1번 실행
                answer = ansewr + i;        //대입 연산 1번 실행
            } else {                        //비교 연산 1번 실행
                answer = answer * answer;   //대입 연산 1번 실행
            }                               //N + 5
        }                                   //시간 복잡도 O(N)
        return answer;
    }
```

## 핵심 요약

1. 실제 성능 비교에서는 최선의 경우보다, 항상 보장되는 최악의 경우(Big-O)를 기준으로 판단한다.  
2. 복잡도 계산 시 상수를 제외하고 지수의 차이를 비교한다.
3. 공간 복잡도가 상수일때 시간복잡도를 비교 해야한다.
