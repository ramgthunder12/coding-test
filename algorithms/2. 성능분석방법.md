# 성능 측정

## 측정 방법

### Time complexity 시간복잡도

연산의 횟수를 계산하는 방법  
- N : 입력 받은 값의 길이 만큼 연산 하는 횟수
- 반복문 안에서의 연산 횟수는, 한 반복안에서 실행 되는 횟수로 계산 해야 한다.

**예시**
```python
    for number in array:                 # array 의 길이만큼 아래 연산이 실행
        is_max_num = True                # 대입 연산 1번 실행
        for compare_number in array:     # array 의 길이만큼 아래 연산이 실행
            if number < compare_number:  # 비교 연산 1번 실행
                is_max_num = False       # 대입 연산 1번 실행
        if is_max_num:                   # 비교 연산 1번 실행
            return number
    
# N * (1 + N(1 + 1) + 1)
# = 2N² + 2N
# 시간 복잡도 O(N²)


    max_num = array[0]                    # 대입 연산 1번 실행
    for num in array:                     # array 의 길이 만큼 아래 연산이 실행
        if num > max_num:                 # 비교 연산 1번 실행
            max_num = num                 # 대입 연산 1번 실행
    return max_num

# 1 + N(1 + 1)
# = 2N + 1
# 시간 복잡도 O(N)
```

### Space complexity 공간복잡도

데이터가 저장되는 공간의 갯수를 계산하는 방법  
1. 배열 : 배열의 길이 만큼 공간의 갯수를 가진다.
2. 변수 : 변수의 갯수 만큼 공간의 갯수를 가진다.

```python
    alphabet_array = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z"]
# -> 26 개의 공간을 사용합니다
    max_occurrence = 0 # 1개의 공간을 사용합니다
    max_alphabet = alphabet_array[0]   # 1개의 공간을 사용합니다.

    for alphabet in alphabet_array:
        occurrence = 0  # 1개의 공간을 사용합니다

# 공간의 갯수 = 29
# 공간 복잡도 O(1)


    alphabet_occurrence_list = [0] * 26 # -> 26 개의 공간을 사용합니다

    for char in string:
        if not char.isalpha():
            continue
        arr_index = ord(char) - ord('a')  # 1개의 공간을 사용합니다
        alphabet_occurrence_list[arr_index] += 1

    max_occurrence = 0                   # 1개의 공간을 사용합니다
    max_alphabet_index = 0               # 1개의 공간을 사용합니다
    for index in range(26):
        alphabet_occurrence = alphabet_occurrence_list[index] # 1개의 공간을 사용합니다
        if alphabet_occurrence > max_occurrence:
            max_occurrence = alphabet_occurrence
            max_alphabet_index = index

# 공간의 갯수 = 30
# 공간 복잡도 O(1)
```


## 표기 방법

### Big-O

최악의 성능을 표기하는 방법  
최고로 걸리는 시간을 기준으로 분석한 방법이다.

### Big-Ω

최선의 성능을 표기하는 방법  
최소로 걸리는 시간을 기준으로 분석한 방법이다.

## 핵심 요약

1. 실제 성능 비교에서는 최선의 경우보다, 항상 보장되는 최악의 경우(Big-O)를 기준으로 판단한다.  
2. 복잡도 계산 시 상수보다는 지수의 차이가 더 중요하다.
3. 공간 복잡도가 상수일때 시간복잡도를 비교 해야한다.
